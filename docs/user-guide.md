# Mir User Guide

## What is Mir?

Mir is a new way to interface with large language models. It is currently _work-in-progress_.

## Configuration

### How do I configure settings?

The Settings panel can be opened using the gear icon in the top right of the application window, or the "Settings..." menu option in the Application menu.

The Settings panel is shown automatically on app launch until a connection is configured.

### How do I connect Mir to an API?

Open Settings and in the Connection section enter the base API URL (OpenAI `OPENAI_BASE_URL` style). Add the API key if the endpoint requires one.

The base URL should look like

```sh
https://api.openai.com/v1
```

Mir will call the `/chat/completions` path on that base URL. This is the only API endpoint the app currently uses.

Most inference providers, including OpenAI itself, provide support for this so called "Chat completion" endpoint (Anthropic is the notable exception).

You can also optionally specify a model name in Settings (for example `gpt-5.2`). The placeholder in the input field is only an example value, not a default that Mir sends automatically. Depending on your inference provider, the model name might be required or optional (if the inference provider has a default model).

The base URL and model is saved on your device so you do not need to re-enter them. The API key is also stored, but using secure storage.

### Where is the API key stored?

If secure storage is available on your device, Mir encrypts your key and saves it on your devices' secure storage so that you do not have to re-enter it each time.

If secure storage is not available, Mir keeps your key only for the current session. The key is cleared when the app closes.

### What data is sent to the API?

Mir sends the current conversation context to the configured endpoint in a chat-completions format, along with your API key if provided.

### Will my settings sync across devices?

Not yet. Sync is planned and will use end-to-end encryption when it is introduced.

### How do I clear my key?

Delete the API key from the Connection section. If secure storage is available, Mir will also remove the saved entry.

## Primitives

### Underlying

LLMs (as of today) take a string of input tokens, and generate a string of output tokens.

A common API interface that has _pseudo_-standardized over this mechanism is to consider the input as a sequence of "messages" (where each message is a string of tokens), and then treat the output as just another message. Then output of the previous interaction (a message) simply becomes part of the input for the next interaction (a sequence of messages).

These input messages are called "context".

What goes into context is entirely up to our imagination.

### Mir

So the underlying primitives that Mir deals with are _messages_ and _context_. These are roughly mapped over from the Mir primitives, _blocks_ and _collections_.

* Blocks are immutable strings of tokens, written by a human, generated by an LLM, or conjured by some other alchemy. These map cleanly to _messages_.

* However, the context is not reified until the actual generation. We have an infinite field of blocks which can be combined in arbitrary ways, but to keep things manageable and tangible, blocks are grouped into collections, and when forming the _context_, a subset of blocks from the collection are used.

## Collections

A new collection can be started using the New Collection button in the top bar, or via File -> New Collection (`Ctrl + N` on Linux/Windows, `Cmd + N` on macOS).

The list of collections can be seen in the Collections tab of the sidebar (Use `Ctrl + E` on Linux/Windows, `Cmd + E` on macOS to jump to this tab. If the sidebar is closed, this opens it).

Collection titles are automatically derived from your first message. Mir cleans markdown/bullet syntax and keeps titles concise so they stay readable in the sidebar.

Collection rows show relative age (`m/h/d/M/y ago`) for fast scanning. Exact timestamps remain available in Inspect.

## Search

Mir supports full-text search across blocks in all collections.

- Open the Search tab in the sidebar, or press `Ctrl + F` on Linux/Windows or `Cmd + F` on macOS.
- If Search is already open, the same shortcut focuses the search input and selects the current query.
- Type a query to search block content. Queries must be at least 2 characters.
- Search uses smart case matching: case-insensitive by default, but case-sensitive if the query contains uppercase letters.
- Matches are prefix-based by term, so partial words can match.
- Results include persisted collections and the built-in demo collection.
- Results are grouped by collection, with per-collection match counts.
- If a collection title matches but no block content in that collection matches, Mir shows an `Open collection` row for that section.
- Select a result to jump to that block and its collection. This clears the current block selection and scrolls to the target block without selecting it.
- Keyboard navigation: from the search input, `Arrow Down` moves focus into results; inside results, `Arrow Up`/`Arrow Down` moves between results (including `Open collection` rows).
- Results are capped to the top 80 matches; Mir shows a note when more matches exist.

Search indexing is local-only. The index is built on first search, updated incrementally as new blocks are added, and rebuilt on demand when needed (for example after imports or destructive data changes).

## Blocks

A new block can be added to a collection using the composer at the bottom of the main pane.

Tokens you add form a new block, are folded into the current context as a message, the resultant context is submitted to the model for generation, and the model’s continuation is stored as a new block.

### Composing blocks

Compose a block in the composer area. Use the Generate Continuation action to add it into the context and trigger the generation of a continuation.

You can also use keyboard shortcuts:

- Press `Enter` to complete the block and generate a continuation.
- Use `Shift + Enter` to insert a newline.
- `Ctrl + Enter` on Linux/Windows or `Cmd + Enter` on macOS also submits as an alternate shortcut.

### Branching

Mir supports branching within a collection.

Branching means a single parent block can have multiple continuations. Mir shows one active branch path in the stream at a time.

The two primary branch actions are:

- Generate new: Create another continuation from the same selected parent block.
- Branch from here: Use the selected generated block as the source for future continuations.

How to use branching in the UI:

- Click any block to select it. The selection bar above the composer appears with the label Selected.
- The selection bar can show Branch from here, Generate new, Copy block, and Clear selection depending on the selected block state.
- Using Copy block from the selection bar copies the selected block and clears the selection.
- If the selected block is already the branch source, Branch from here is disabled.
- Blocks with multiple children show a layers marker with a count (for example 3 branches). Click it to open Branches panel focused on that branch point.
- Use Branches in the header (layers icon) to open or close Branches panel.
- You can also toggle Branches panel with `Ctrl + Shift + B` on Linux/Windows or `Cmd + Shift + B` on macOS.
- In Branches panel, select a branch point in the top row, then select a branch (Branch 1, Branch 2, and so on) in the list.
- Use Latest in Branches panel to jump back to the latest branch path.
- When you are on a non-latest path, the selection bar label changes to Branch path, shows Off latest path, and offers Latest path to return.

To roll a new generation from the same user prompt, select that user block and use Generate new.

If a generation fails, Mir keeps the pending generated block and shows Generate new on that block so you can retry without duplicating the user block.

### Customizing generation parameters

You can customize parameters passed to the model along with the context when asking it to generate a continuation. Mir currently exposes temperature and first-generation system prompt selection.

#### Temperature

The TEMP pill near the Add button lets you set the temperature for the next continuation.

Temperature controls how deterministic or varied the model output is. Lower values are more focused and repeatable; higher values are more exploratory.

#### System prompt blocks

Mir can seed a new collection with a saved `system` block before the first generation.

- Select a block, open **Inspect**, and use the repo icon to save or remove that block as a reusable system prompt.
- Saved system prompts can be used across collections.
- Saved system prompts are stored as normal blocks and linked to their source block via a `source` relation, so they are part of normal export/import sync data.
- System prompt selection is available only in a new, empty collection before the first generation.
- In that empty state, a compact `Sys` indicator near the composer border shows the current choice (`—` for none, `<N> ch` when a prompt is selected).
- Click the indicator to open an inline selector panel with a compact action bar and a scrollable list of saved prompts.
- The action bar always shows `None` and `New`.
- Use `None` to clear selection for the current draft (`None` is disabled when nothing is selected).
- Use `New` to create a prompt directly from the panel.
- If no prompts are saved yet, the panel shows an empty-state hint and keeps `New` available.
- Selecting a prompt in the list keeps the selector panel open so you can continue browsing or use row actions.
- The new-collection selector remembers your last choice on this device and preselects it for the next new collection draft.
- Each saved prompt row in the selector has `Edit prompt` and `Go to source block` icon actions.
- `Go to source block` is always shown; it is disabled when no source relation exists.
- Expanded edit view keeps `Cancel` and `Save` text actions, plus icon-only delete controls (`trash` -> `confirm` / `cancel`) to remove a prompt from the library.
- Saving an edit creates a new immutable system prompt block, keeps the previous revision for history, and updates library membership to point at the new revision.
- When selected, that system prompt block is linked into the new collection ancestry and used in context like any other parent block.
- Unsaving a system prompt removes it from the library picker for future drafts without changing existing collections that already reference it.

## Inspect

The Inspect tab in the sidebar shows metadata about the selected collection or block.

The top area displays a compact summary meant for a quick scan, starting with the local time when the item was created.

For generated blocks, this area will also show the model name, the completion token count and the response latency.

This summary is followed by any actions applicable to that item type.

* Copy Collection: Copy all blocks in the selected collection as markdown. Blocks with a role "user" are blockquoted.
* Delete Collection: Delete the collection and all of its blocks. This action asks for a confirmation first.
* Copy Block: Copy the block's text.
* Branch from here: Move the branch source to the selected generated/model block.
* Generate new: Re-run generation from the selected user block or retry a failed generated/model block.
* Save as system prompt: Save or remove the selected block as a reusable system prompt.

This is then followed by various sections giving low-level details about the active item, whichever are applicable:

#### Block

- Time: Full local timestamp of the block.
- Role: The block role (user, assistant, system).
- Words: Word count for the block content.
- Characters: Character count for the block content.

#### Request (for generated blocks)

- Engine: The local engine which performed the inference (for local generations).
- Endpoint: The base URL of the inference provider (for remote generations).
- Model: The name of the model specified in the completion request.
- Temperature: Sampling temperature used by the request.

#### Response (for generated blocks)

- Model: The model used for the chat completion (shown when it differs from the requested model).
- Latency: The total time in milliseconds between sending the request and receiving the response.
- Prompt tokens: Number of tokens in the prompt.
- Completion tokens: Number of tokens in the generated completion.
- Total tokens: Total tokens used (prompt + completion).
- Finish reason: The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `tool_calls` if the model called a tool, and other provider specific values.
- Response ID: The provider's unique identifier for the generated completion.

## Export and Import

Mir stores your data locally in the app's container on your device.

You can use the export and import functionality in the Data section of Settings to export a snapshot to a JSON file and later import it back. You can use this as a backup mechanism, or to move your data between devices.

### Exporting data

1. Open Settings.
2. Under Data, click Export data.
3. Choose a location for the JSON file (Mir suggests a timestamped filename).

The export includes collections, blocks, and relationships. It does not include API keys, local settings, or other device‑specific data.

### Importing data

1. Open Settings.
2. In Data, click Import data.
3. Review the preview counts and confirm the import by pressing Import now.

Mir merges the import into your existing data:

- Records and relationships are additive.
- If an incoming record ID already exists, Mir keeps the current version and reports a conflict.
- If a relationship points to a missing or deleted record, Mir skips it.

If the imported data contains divergent continuations from the same parent block, those divergences are preserved and shown as branches.

This means import will not overwrite your current work or resurrect deleted content. If you need a clean slate, you will need to clear the local database before importing.

To summarize, the import is

- Safe and additive; it will only add what is new.
- Will not create duplicates; both records relationships are de‑duplicated by identity, so re‑imports are idempotent.
- And will show you a preview first, mentioning counts of what all is in the file that is being imported.

## Other features

- Automatic light/dark mode that follows the system's setting.
- Easy controls for customizing generation parameters for each block.
- Markdown and TeX math typesetting support.
- Keyboard friendly design, with handy and documented keyboard shortcuts for navigation and various functions.

## Keyboard shortcuts

| Action | Linux/Windows | macOS |
| --- | --- | --- |
| New Collection | Ctrl + N | Cmd + N |
| Open Settings | Ctrl + , | Cmd + , |
| Toggle Side Bar | Ctrl + B | Cmd + B |
| Show Collections | Ctrl + E | Cmd + E |
| Show Inspect | Ctrl + I | Cmd + I |
| Show Search (focus query) | Ctrl + F | Cmd + F |
| Toggle Branches Panel | Ctrl + Shift + B | Cmd + Shift + B |
| Focus composer | Ctrl + L | Cmd + L |
| Select previous block | Up | Up |
| Select next block / Focus composer | Down | Down |
| Copy active block (no text selection) | Ctrl + C | Cmd + C |
| Clear selection / Blur composer | Esc | Esc |
| Scroll to top | Ctrl + Up | Cmd + Up |
| Scroll to end | Ctrl + Down | Cmd + Down |
| Generate Continuation | Enter | Enter |
| New line | Shift + Enter | Shift + Enter |
| Generate Continuation (alternate shortcut) | Ctrl + Enter | Cmd + Enter |
